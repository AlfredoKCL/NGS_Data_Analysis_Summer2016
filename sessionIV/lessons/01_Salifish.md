---
title: "Alignment-free expression estimation using Sailfish"
author: "Radhika Khetani"
date: "Sunday, February 28, 2016"
---

Contributors: Meeta Mistry

Approximate time: 2 hours

## Learning Objectives

* Understand the concept of "Pseudocounts"
* Understand how to use Sailfish to generate Pseudocounts
* Learn how to perform differential gene expression on Pseudocounts

## What is Sailfish?

[Sailfish](http://www.cs.cmu.edu/~ckingsf/software/sailfish/index.html) and it's more recent "upgrade" [Salmon](https://combine-lab.github.io/salmon/), are based on the philosophy of lightweight algorithms. They use the sequence of genes or transcripts as input, and do not align the whole read. Instead it's a 2-step process based on counting "kmers":

**a.** they first evaluate the sequences for all possible unique sequences of length k (kmer) in the **transcriptome** (genes/transcripts) to create an index. The Sailfish index has four components: 

* (1) a perfect hash containing the number of unique k-mers per transcript 
* (2) an array recording the number of times each k-mer occurs in the reference set
* (3) an index mapping each **transcript to the multiset of k-mers** that it contains
* (4) an index mapping each **k-mer to the set of transcripts** in which it appears.

**b.** then they count the number of times those kmers appear in the **sequenced reads**, i.e. the fastq. This count information is used to figure out which transcript the read probably came from, and estimate the abundance of each gene or transcript. 

<img src="../img/nbt.2862-F1.jpg" width="400">

## Running Sailfish on Orchestra

First start an interactive session and create a new directory for our Sailfish analysis:

    bsub -Is -q interactive bash

    mkdir ~/ngs_course/rnaseq/sailfish
    cd ~/ngs_course/rnaseq/sailfish
    
Sailfish is not available as a module on Orchestra, but it is installed as part of the bcbio pipeline. As such, if we include the appropriate paths in our $PATH variable we can use it:
    
    export PATH=/groups/bcbio/bcbio/anaconda/bin:/opt/bcbio/local/bin:$PATH
    
As you can imagine from the above schematic, taken from [Patro R. et al, 2014](http://www.nature.com/nbt/journal/v32/n5/full/nbt.2862.html), there are 2 steps when running the analysis too:

a. "Index" the transcriptome (transcripts or genes) using the `index` command:
    
    sailfish index -p <num of cores> -k <kmer size> -t <fasta of gene sequences> 
                         -o <folder name>

**We are not going to run this in class, but it only takes a few minutes.** We will be using an index we have generated from transcript sequences (all known transcripts with multiples for some genes), but this can be generated from genic sequences too. 

b. Get the abundance using the quantification step using the `quant` command and the parameters described below (mor information on parameters can be found [here](http://sailfish.readthedocs.org/en/master/sailfish.html#description-of-important-options):


   * `-l SR`: specify stranded single-end reads
   * `-r ngs_course/rnaseq/data/untrimmed_fastq/Mov10_oe_1.subset.fq `: list of files
   * `--useVBOpt`: use variational Bayesian EM algorithm rather than the ‘standard EM’ to optimize abundance estimates (more accurate) 
   * `-o`: output quantification file name

Let's run the quantification step on the `Mov10_oe_1.subset` sample:

``` 
    sailfish quant -i /groups/hbctraining/sailfish-run/sailfish.ensembl2.idx/ \
    -l SR \
    -r ~/ngs_course/rnaseq/data/untrimmed_fastq/Mov10_oe_1.subset.fq \
    --useVBOpt \
    -o Mov10_oe_1.subset.sailfish
```

Take a look at what is contained in the `quant.sf` file:

    less Mov10_oe_1.subset.sailfish/quant.sf
  
You would need to run this command on each sample in your dataset and transfer  all resulting quant tables to your laptop to perfrom the DE analysis using R. 

## Switching over to R

We have already performed these additional Sailfish runs for you and you can download the directory with all the necessary files [from here](https://dl.dropboxusercontent.com/u/74036176/sailfish.zip). Once you download it, please do the following:
* Decompress the tar archive
* Open RStudio
* Go to the files tab and find your way to the new folder you downloaded
* Set that folder your working directory
* Start a new R script

## Converting Sailfish output to pseudo-counts and performing DE analysis

The pseudocounts generated by Sailfish are represented as normalized TPM (transcripts per million) counts and map to transcripts or genes, depending on the input in the index step. These need to be converted into non-normalized count estimates for performing DESeq2 analysis. In addition, we need to be able to input the resulting non-normalized values which contain decimal places to create the DESeq object. 

### Setting up to run DESeq2 on pseudocount data:

The developers of DESeq2 are aware of the above-mentioned issues, so they:

* have developed a package that can make this conversion to non-normalized pseudocounts ([tximport](https://github.com/mikelove/tximport#update-now-hosted-on-bioconductor))
* have also created a new custom function that enables DESeq2 to accept decimal places in count values to generate a DESeq object

The `tximport` package available on Bioconductor is currently too new and will not work with our regular R installation. *This is only temporary and will change after April 2016.* In the meantime, we have to grab an older version from GitHub. To download R packages from GitHub, we need a new package called `devtools`.

**Step 1.** Install all the new packages required (you'll only need to do this once)
    
    # Install devtools to be able to install packages from GitHub
    install.packages("devtools")
    library(devtools)   # required for installing any packages from github
    
    # Install from GitHub
    install_github("mikelove/tximport")  
	
    # Install from CRAN
    install.packages("readr")       # required to generate the output from tximport

    # Install from Bioconductor
    source("http://bioconductor.org/biocLite.R")
    biocLite("biomaRt")             # tximport requires gene symbols as row names
    
**Step 2.** Load the libraries required for setting up

    library(tximport)
    library(readr)
    library(biomaRt)

**Step 3.** Load the data from the working directory (which is the folder we downloaded earlier)

```
    ## Load in data    
    samples <- scan("samples.txt", what="character")
    
    ## Obtain a vector of all filenames including the path
    files <- file.path(samples, "quant.sf")
    
    ## Since all quant files have the same name it is useful to have names for each element
    names(files) <-  samples
 ```
    
> **OPTION 2: An alternative to this is having absolute paths instead of relative paths.** This would be useful so you can run this from anywhere in your filesystem.
>

	dir <- getwd()
	files <- file.path(dir, samples, "quant.sf")
	
	## Create your own function
	assignNames <- function(x){
			strsplit(x, "/")[[1]][6]
			}
	names(files) <- sapply(files, assignNames, USE.NAMES=F)

Either of these methods will work, or even a combination of the two. The main objective here is to add names to our quant files which will allow us easily discriminate between samples in the final output matrix. 

**Step 4.** Create a data frame containing Ensembl Transcript IDs and Gene symbols

Our Sailfish index was generated with transcript sequences, but tximport needs to know which Genes these transcripts came from, so we need to use the `biomaRt` package to extract this information.

    head(read.delim(files[1], sep="\t", header=T))
    
    ids <- read.delim(files[1], sep="\t", header=T)
    
    ids <- as.character(ids[,1])
   

**NOTE a: Do not run the next section of code**, this code is for future reference only. The `getBM()` function takes a long time to run, so we have already generated the information the `tx2gene` data frame needs to have. *Mary will be going over the `getBM` function in more detail in the Ensembl/Biomart lesson.*
    
    # mart<- useDataset("hsapiens_gene_ensembl", useMart("ENSEMBL_MART_ENSEMBL", host="www.ensembl.org"))
    # gene.names <- getBM(
    #    filters= "ensembl_transcript_id", 
    #     attributes= c("ensembl_gene_id", "external_gene_name", "ensembl_transcript_id"),
    #    values= ids,
    #    mart= mart)
    # tx2gene <- gene.names[,3:2]
    
**NOTE b: Run the following code in class**, but remember that if you obtain the values from biomaRt directly, you won't have to run it.

    tx2gene <- read.table("tx2gene.txt", header=T)
    
**Step 5:** Run tximport to summarize gene-level information    
  
    txi <- tximport(files, type="sailfish", txIn = TRUE, txOut = FALSE, tx2gene=tx2gene, reader=read_tsv)
  
### Using DESeq2 for DE analysis with pseudocounts
    
    library(DESeq2)
    source('DESeqDataFromTx.R') # required for using tximport output as input for DESeq2
    
    ## Create a sampletable/metadata
    condition=factor(c(rep("Ctl",3), rep("KD", 2), rep("OE", 3)))
    sampleTable <- data.frame(condition, row.names = colnames(txi$counts))
    
    ## Create a DESeqDataSet object
    dds <- DESeqDataSetFromTximport(txi, sampleTable, ~ condition)
    
Now you have created a DESeq object to proceed with DE analysis as we discussed in the last session!

***
*This lesson has been developed by members of the teaching team at the [Harvard Chan Bioinformatics Core (HBC)](http://bioinformatics.sph.harvard.edu/). These are open access materials distributed under the terms of the [Creative Commons Attribution license](https://creativecommons.org/licenses/by/4.0/) (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.*
